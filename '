#include "chess.h"
#include <stdio.h>
#include <math.h>
#include <assert.h>

void initGame(Game* game)
{
	Position pos;
	for (int i = 2; i < 6; i++) {
		pos = i << 3;
		for (int j = 0; j < 8; j++) {
			game->refBoard[pos] = NONE;
			game->board[pos] = NONE;
			pos++;
		}
	}

	game->cntPieces[0] = game->cntPieces[1] = 0;
	for (int color = 0; color < 2; color++) {
		int cnt = 0;
		createPiece(color, KING, color * 7, 4, game);
		createPiece(color, QUEEN, color * 7, 3, game);
		createPiece(color, BISHOP, color * 7, 2, game);
		createPiece(color, BISHOP, color * 7, 5, game);
		createPiece(color, KNIGHT, color * 7, 1, game);
		createPiece(color, KNIGHT, color * 7, 6, game);
		createPiece(color, ROOK, color * 7, 0, game);
		createPiece(color, ROOK, color * 7, 7, game);
		for (int i = 0; i < 8; i++) {
			createPiece(color, PAWN, color * 5 + 1, i, game);
		}
	}

	game->state = ONGOING;
	game->moveCnt = 0;
	game->totalMoves = 0;
	game->lastPawnOrCapture = 0;
	game->colorToMove = WHITE;
	game->enPassantFile = NONE;
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			game->whenLostCR[i][j] = NEVER;
		}
	}
	/*
	for (int i = 0; i < 2; i++) {
		printBitboard(game->piecesBB[i]);
		for (int j = 0; j < 6; j++) {
			printBitboard(game->pieceTypeBB[i][j]);
		}
	}
	*/
}

void createPiece(PieceColor color, PieceType type,
	uint8_t rank, uint8_t file, Game* game)
{
	Piece p;
	p.info = getPieceInfo(color, type);
	p.pos = getPos(rank, file);
	game->pieces[color][game->cntPieces[color]] = p;
	game->board[p.pos] = p.info;
	game->refBoard[p.pos] = color * 16 + game->cntPieces[color];
	game->cntPieces[color]++;
	setBit(game->piecesBB[color], p.pos);
	setBit(game->pieceTypeBB[color][type], p.pos);
}

bool isPosEmpty(Position pos, const Game* game)
{
	return game->refBoard[pos] == NONE;
}

bool isPosEmptyOrInvalid(Position pos, const Game* game)
{
	return !isPosValid(pos) || isPosEmpty(pos, game);
}

Piece getPiece(Position pos, const Game* game)
{
	assert(isPosValid(pos) && !isPosEmpty(pos, game));
	return *((Piece*)game->pieces + game->refBoard[pos]);
}

static Piece* getPiecePtr(Position pos, Game* game)
{
	assert(isPosValid(pos) && !isPosEmpty(pos, game));
	return ((Piece*)game->pieces + game->refBoard[pos]);
}

Piece getPieceByRef(PieceRef ref, const Game* game)
{
	assert(ref >= 0 && ref < 32);
	return *((Piece*)game->pieces + ref);
}

static Piece* getPiecePtrByRef(PieceRef ref, Game* game)
{
	assert(ref >= 0 && ref < 32);
	return ((Piece*)game->pieces + ref);
}

PieceColor getPieceColor(PieceInfo p)
{
	return p >> 3;
}

PieceColor getEnemyColor(PieceColor color)
{
	if (color == WHITE)
		return BLACK;
	else
		return WHITE;
}

PieceType getPieceType(PieceInfo p)
{
	return p & 0b111;
}

PieceInfo getPieceInfo(PieceColor color, PieceType type)
{
	return color << 3 | type;
}

bool isPosValid(Position pos)
{
	return pos >= 0 && pos < 64;
}

RankFile getRankFile(Position pos)
{
	return (RankFile){ .rank = pos >> 3, .file = pos & 0b111 };
}

uint8_t getRank(Position pos)
{
	return pos >> 3;
}

uint8_t getFile(Position pos)
{
	return pos & 0b111;
}

Position getPos(uint8_t rank, uint8_t file)
{
	return rank << 3 | file;
}

Position notationToPos(char* notation)
{
	Position pos;
	uint8_t file = notation[0] - 'a';
	uint8_t rank = notation[1] - '1';
	return getPos(rank, file);
}

void posToNotation(Position pos, char* notation)
{
	RankFile rf = getRankFile(pos);
	notation[0] = rf.file + 'a';
	notation[1] = rf.rank + '1';
}

void movePiece(Position from, Position to, Game* game)
{
	Piece* piece = getPiecePtr(from, game);
	piece->pos = to;

	game->board[to] = game->board[from];
	game->board[from] = NONE;

	game->refBoard[to] = game->refBoard[from];
	game->refBoard[from] = NONE;
	
	PieceColor color = getPieceColor(piece->info);
	PieceType type = getPieceType(piece->info);

	resetBit(game->piecesBB[color], from);
	setBit(game->piecesBB[color], to);
	resetBit(game->pieceTypeBB[color][type], from);
	setBit(game->pieceTypeBB[color][type], to);
}

PieceRef capturePiece(Position pos, Game* game)
{
	PieceRef ref = game->refBoard[pos];
	Piece* piece = getPiecePtrByRef(ref, game);
	piece->pos = NONE;
	game->board[pos] = NONE;
	game->refBoard[pos] = NONE;

	PieceColor color = getPieceColor(piece->info);
	PieceType type = getPieceType(piece->info);

	resetBit(game->piecesBB[color], pos);
	resetBit(game->pieceTypeBB[color][type], pos);
	return ref;
}

void undoCapture(Position pos, PieceRef piece, Game* game)
{
	getPiecePtrByRef(piece, game)->pos = pos;
	game->refBoard[pos] = piece;
	game->board[pos] = getPieceByRef(piece, game).info;
}

PieceRef enPassant(Position from, Position to, Game* game)
{
	movePiece(from, to, game);
	return capturePiece(getPos(getRank(from), getFile(to)), game);
}

void undoEnPassant(Position from, Position to, PieceRef captured, Game* game)
{
	movePiece(to, from, game);
	undoCapture(getPos(getRank(from), getFile(to)), captured, game);
}

void castle(Position from, Position to, Game* game)
{
	movePiece(from, to, game);
	RankFile rook, rookTo;
	rook.rank = getRank(from);
	rookTo.rank = rook.rank;
	if (getFile(to) == 2) {
		rook.file = 0;
		rookTo.file = 3;
	}
	else {
		rook.file = 7;
		rookTo.file = 5;
	}
	movePiece(getPos(rook.rank, rook.file), getPos(rookTo.rank, rookTo.file), game);
	if (rook.rank == 0) {
		takeCastlingRights(WHITE, QUEENSIDE, game);
		takeCastlingRights(WHITE, KINGSIDE, game);
	}
	else {
		takeCastlingRights(BLACK, QUEENSIDE, game);
		takeCastlingRights(BLACK, KINGSIDE, game);
	}
}

void undoCastle(Position from, Position to, Game* game)
{
	movePiece(to, from, game);
	RankFile rook, rookTo;
	rook.rank = getRank(from);
	rookTo.rank = rook.rank;
	PieceColor c;
	CastleSide side;
	if (getRank(from) == 0) c = WHITE;
	else c = BLACK;
	if (getFile(to) == 2) {
		rook.file = 0;
		rookTo.file = 3;
		side = QUEENSIDE;
	}
	else {
		rook.file = 7;
		rookTo.file = 5;
		side = KINGSIDE;
	}
	movePiece(getPos(rook.rank, rook.file), getPos(rookTo.rank, rookTo.file), game);
}

void takeCastlingRights(PieceColor c, CastleSide side, Game* game)
{
	if (game->whenLostCR[c][side] > game->moveCnt)
		game->whenLostCR[c][side] = game->moveCnt;
}

// must be called when making a new move
// must not be called when redoing an undone move
void updateCastlingRights(Position pos, Game* game)
{
	if (game->moveCnt < game->totalMoves) {
	// if we're moving after undoing,
	// this condition will be true.
	// here we check if we lost castling rights during
	// the moves that we undid, if so reset whenLostCR to NEVER.
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) {
				if (game->whenLostCR[i][j] >= game->moveCnt) {
					game->whenLostCR[i][j] = NEVER;
				}
			}
		}
	}

	PieceColor c;
	uint8_t rank = getRank(pos);
	uint8_t file = getFile(pos);

	if (rank == 0) c = WHITE;
	else if (rank == 7) c = BLACK;
	else return;
	if (file == 0) { // queenside rook
		takeCastlingRights(c, QUEENSIDE, game);
	} else if (file == 7) { // kingside rook
		takeCastlingRights(c, KINGSIDE, game);
	} else if (file == 4) { // king
		takeCastlingRights(c, QUEENSIDE, game);
		takeCastlingRights(c, KINGSIDE, game);
	}

}

void changeType(Position pos, PieceType type, Game* game)
{
	Piece* p = getPiecePtr(pos, game);
	p->info += type - getPieceType(p->info);
}

char getPieceSymbol(PieceInfo p)
{
	PieceType type = getPieceType(p);
	PieceColor color = getPieceColor(p);
	switch (type)
	{
	case PAWN:
		return 'P' + 32 * color;
	case KNIGHT:
		return 'N' + 32 * color;
	case BISHOP:
		return 'B' + 32 * color;
	case ROOK:
		return 'R' + 32 * color;
	case QUEEN:
		return 'Q' + 32 * color;
	case KING:
		return 'K' + 32 * color;
	default:
		return '0' + type;
	}
}

PieceInfo symbolToPiece(char c)
{
	PieceColor color;
	if (c >= 'A' && c <= 'Z') {
		color = WHITE;
	} else if (c >= 'a' && c <= 'z') {
		color = BLACK;
		c -= 32; // to uppercase
	} else {
		return NONE;
	}
	switch (c)
	{
	case 'P':
		return getPieceInfo(color, PAWN);
	case 'N':
		return getPieceInfo(color, KNIGHT);
	case 'B':
		return getPieceInfo(color, BISHOP);
	case 'R':
		return getPieceInfo(color, ROOK);
	case 'Q':
		return getPieceInfo(color, QUEEN);
	case 'K':
		return getPieceInfo(color, KING);
	default:
		return NONE;
	}
}

void printBoard(const Game* game)
{
	Position pos;
	printf(" +");
	for (int j = 0; j < 8; j++) {
		printf("-+");
	}
	printf("\n");
	for (int i = 7; i >= 0; i--) {
		pos = i << 3;
		printf("%d|", i + 1);
		for (int j = 0; j < 8; j++) {
			if (isPosEmpty(pos, game)) printf(" |");
			else printf("%c|", getPieceSymbol(game->board[pos]));
			pos++;
		}
		printf("\n");
		printf(" +");
		for (int j = 0; j < 8; j++) {
			printf("-+");
		}
		printf("\n");
	}
	printf("  ");
	for (int j = 0; j < 8; j++) {
		printf("%c ", 'a' + j);
	}
	printf("\n");
}

void printBoardFlipped(const Game *game)
{
	Position pos;
	printf(" +");
	for (int j = 0; j < 8; j++) {
		printf("-+");
	}
	printf("\n");
	for (int i = 0; i < 8; i++) {
		pos = i << 3 | 7;
		printf("%d|", i + 1);
		for (int j = 7; j >= 0; j--) {
			if (isPosEmpty(pos, game)) printf(" |");
			else printf("%c|", getPieceSymbol(game->board[pos]));
			pos--;
		}
		printf("\n");
		printf(" +");
		for (int j = 7; j >= 0; j--) {
			printf("-+");
		}
		printf("\n");
	}
	printf("  ");
	for (int j = 7; j >= 0; j--) {
		printf("%c ", 'a' + j);
	}
	printf("\n");
}

bool isMovePromotion(Position from, Position to, const Game* game)
{
	PieceInfo p = game->board[from];
	uint8_t rank = getRank(to);
	return (p == PIECE(WHITE, PAWN) && rank == 7) ||
		(p == PIECE(BLACK, PAWN) && rank == 0);
}

bool isPromotionValid(Position from, Position to, PieceType prom,
	const Game* game)
{
	if (isMovePromotion(from, to, game) == false) return prom == NONE;
	return prom >= KNIGHT && prom <= QUEEN;
}

// function assumes move is legal, so check move legality before calling
Move makeMove(Position from, Position to, PieceType promotion, Game* game)
{
	Move move;
	move.from = from;
	move.to = to;
	move.type = getMoveType(from, to, game);
	move.captured = NONE;

	game->enPassantFile = NONE;
	switch (move.type)
	{
	case REGMOVE:
		if (getPieceType(game->board[from] == PAWN))
			game->lastPawnOrCapture = game->moveCnt + 1;
		if (isPosEmpty(to, game) == false) {
			move.captured = capturePiece(to, game);
			game->lastPawnOrCapture = game->moveCnt + 1;
		}
		movePiece(from, to, game);
		if (promotion != NONE) {
			printf("Promoted to %d!\n", promotion);
			changeType(to, promotion, game);
			move.type = promotion;
		}
		break;
	case DOUBLESTEP:
		movePiece(from, to, game);
		game->enPassantFile = getFile(from);
		game->lastPawnOrCapture = game->moveCnt + 1;
		break;
	case ENPASSANT:
		move.captured = enPassant(from, to, game);
		game->lastPawnOrCapture = game->moveCnt + 1;
		break;
	case CASTLE:
		castle(from, to, game);
		break;
	default:
		break;
	}

	updateCastlingRights(from, game);
	game->colorToMove = getEnemyColor(game->colorToMove);
	game->history[game->moveCnt++] = move;
	game->totalMoves = game->moveCnt;

	return move;
}

void undoMove(Game* game)
{
	if (game->moveCnt == 0) return;
	Move move = game->history[--game->moveCnt];
	Position from = move.from;
	Position to = move.to;
	switch(move.type)
	{
	case REGMOVE:
		movePiece(to, from, game);
		if (move.captured != NONE) {
			undoCapture(to, move.captured, game);
		}
		break;
	case DOUBLESTEP:
		movePiece(to, from, game);
		break;
	case ENPASSANT:
		undoEnPassant(from, to, move.captured, game);
		break;
	case CASTLE:
		undoCastle(from, to, game);
		break;
	default: // if PROMOTION
		changeType(to, PAWN, game);
		movePiece(to, from, game);
		break;
	}
	game->colorToMove = getEnemyColor(game->colorToMove);

	if (game->moveCnt == 0) {
		game->enPassantFile = NONE;
		return;
	}
	Move prevMove = game->history[game->moveCnt - 1];
	if (prevMove.type == DOUBLESTEP) {
		game->enPassantFile = getFile(prevMove.from);
	} else {
		game->enPassantFile = NONE;
	}
}

void redoMove(Game* game)
{
	if (game->moveCnt == game->totalMoves) return;
	Move move = game->history[game->moveCnt];
	Position from = move.from;
	Position to = move.to;

	game->enPassantFile = NONE;
	switch(move.type)
	{
	case REGMOVE:
		if (move.captured != NONE) {
			capturePiece(to, game);
		}
		movePiece(from, to, game);
		break;
	case DOUBLESTEP:
		movePiece(from, to, game);
		game->enPassantFile = getFile(from);
		break;
	case ENPASSANT:
		enPassant(from, to, game);
		break;
	case CASTLE:
		castle(from, to, game);
		break;
	default: // if PROMOTION
		movePiece(from, to, game);
		changeType(to, move.type, game);
		break;
	}
	game->colorToMove = getEnemyColor(game->colorToMove);
	game->moveCnt++;
}

MoveType getMoveType(Position from, Position to, Game* game)
{
	PieceInfo p = game->board[from];
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	switch(getPieceType(p))
	{
	case PAWN:
		if (abs(from_rank - to_rank) == 2)
			return DOUBLESTEP;
		if (game->enPassantFile != to_file) break;
		if (from_rank == 4 && to_rank == 5) {
			return ENPASSANT;
		}
		if (from_rank == 3 && to_rank == 2) {
			return ENPASSANT;
		}

	case KING:
		if (abs(from_file - to_file) == 2)
			return CASTLE;
		break;
	}
	return REGMOVE;
}

Move moveByNotation(char *notation, Game* game)
{
	Position from = notationToPos(notation);
	Position to = notationToPos(notation + 2);
	PieceInfo piece = symbolToPiece(notation[4]);
	PieceType prom = getPieceType(piece);
	if (prom < KNIGHT || prom > QUEEN) prom = NONE;
	return checkAndMove(from, to, prom, game);
}


bool isWhitePawnMoveLegal(Position from, Position to, const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	PieceRef capture = game->refBoard[to];
	if (capture == NONE) {
		if (from_rank + 1 == to_rank && from_file == to_file) return true;
		if (from_rank == 1 && to_rank == 3 && from_file == to_file) {
			PieceRef between = game->refBoard[getPos(2, from_file)];
			if (between == NONE) {
				return true;
			}
		}
	}
	if (from_rank + 1 == to_rank && abs(from_file - to_file) == 1) {
		if (capture != NONE) {
			return true;
		}
		if (game->enPassantFile == to_file && from_rank == 4) {
			return true;
		}
	}
	return false;
}

bool isBlackPawnMoveLegal(Position from, Position to, const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	PieceRef capture = game->refBoard[to];
	if (capture == NONE) {
		if (from_rank - 1 == to_rank && from_file == to_file) return true;
		if (from_rank == 6 && to_rank == 4 && from_file == to_file) {
			PieceRef between = game->refBoard[getPos(5, from_file)];
			if (between == NONE) {
				return true;
			}
		}
	}
	if (from_rank - 1 == to_rank && abs(from_file - to_file) == 1) {
		if (capture != NONE) {
			return true;
		}
		if (game->enPassantFile == to_file && from_rank == 3) {
			return true;
		}
	}
	return false;
}

bool isPawnMoveLegal(Position from, Position to, const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	PieceColor color = getPieceColor(game->board[from]);
	if (color == WHITE) return isWhitePawnMoveLegal(from, to, game);
	else return isBlackPawnMoveLegal(from, to, game);
}

bool isKnightMoveLegal(Position from, Position to)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	if (abs(from_rank - to_rank) == 2 && abs(from_file - to_file) == 1) return true;
	if (abs(from_rank - to_rank) == 1 && abs(from_file - to_file) == 2) return true;
	return false;
}

bool isBishopMoveLegal(Position from, Position to, const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	if (abs(from_rank - to_rank) != abs(from_file - to_file)) return false;
	int rankdir = from_rank > to_rank ? -1 : 1;
	int filedir = from_file > to_file ? -1 : 1;
	int j = from_file + filedir;
	for (int i = from_rank + rankdir; i != to_rank; i += rankdir) {
		if (game->refBoard[getPos(i, j)] != NONE) return false;
		j += filedir;
	}
	return true;
}

bool isRookMoveLegal(Position from, Position to, const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	if (from_rank != to_rank && from_file == to_file) {
		int rankdir = from_rank > to_rank ? -1 : 1;
		for (int i = from_rank + rankdir; i != to_rank; i += rankdir) {
			if (game->refBoard[getPos(i, from_file)] != NONE) return false;
		}
	}
	else if (from_rank == to_rank && from_file != to_file) {
		int filedir = from_file > to_file ? -1 : 1;
		for (int j = from_file + filedir; j != to_file; j += filedir) {
			if (game->refBoard[getPos(from_rank, j)] != NONE) return false;
		}
	}
	else {
		return false;
	}
	return true;
}

bool isQueenMoveLegal(Position from, Position to, const Game* game)
{
	return isBishopMoveLegal(from, to, game) || isRookMoveLegal(from, to, game);
}

bool isKingMoveLegal(PieceColor color, Position from, Position to,
	const Game* game)
{
	uint8_t from_rank = getRank(from);
	uint8_t from_file = getFile(from);
	uint8_t to_rank = getRank(to);
	uint8_t to_file = getFile(to);

	PieceColor enemyColor = getEnemyColor(color);
	if (isPosUnderAttack(to, enemyColor, game)) return false;
	if (from_rank == color * 7 && from_rank == to_rank && from_file == 4) {
		if (isPosUnderAttack(from, enemyColor, game)) return false;
		uint8_t between_file;
		if (to_file == 2) {
			between_file = 3;
			return isPosEmpty(getPos(from_rank, between_file), game) &&
				!isPosUnderAttack(getPos(from_rank, between_file), enemyColor, game)
				&& game->moveCnt <= game->whenLostCR[color][QUEENSIDE];
		}
		else if (to_file == 6) {
			between_file = 5;
			return isPosEmpty(getPos(from_rank, between_file), game) &&
				!isPosUnderAttack(getPos(from_rank, between_file), enemyColor, game)
				&& game->moveCnt <= game->whenLostCR[color][KINGSIDE];
		}
		else {
			return (to_file == 3 || from_file == 5);
		}

	}
	return abs(from_rank - to_rank) <= 1 && abs(from_file - to_file) <= 1;
}

bool isMoveGenerallyValid(Position from, Position to, const Game* game)
{
	if (isPosValid(from) == false || isPosValid(to) == false)
		return false;

	if (from == to) return false;

	if (isPosEmpty(from, game)) {
		return false;
	}

	PieceColor pieceColor = getPieceColor(game->board[from]);
	if (pieceColor != game->colorToMove) {
		printf("Not your piece!\n");
		return false;
	}

	if (isPosEmpty(to, game) == false) {
		if (pieceColor == getPieceColor(game->board[to])) {
			printf("Your other piece is blocking!\n");
			return false;
		}
	}

	return true;
}

bool isMoveLegal(Position from, Position to, const Game* game)
{
	if (isMoveGenerallyValid(from, to, game) == false) return false;
	PieceInfo piece = game->board[from];

	switch (getPieceType(piece))
	{
	case PAWN:
		if (getPieceColor(piece) == WHITE)
			return isWhitePawnMoveLegal(from, to, game);
		else
			return isBlackPawnMoveLegal(from, to, game);
	case KNIGHT:
		return isKnightMoveLegal(from, to);
	case BISHOP:
		return isBishopMoveLegal(from, to, game);
	case ROOK:
		return isRookMoveLegal(from, to, game);
	case QUEEN:
		return isQueenMoveLegal(from, to, game);
	case KING:
		return isKingMoveLegal(getPieceColor(piece), from, to, game);
	default:
		return false;
	}
}

Move checkAndMove(Position from, Position to, PieceType prom,
	Game* game)
{
	Move move;
	if (isMoveLegal(from, to, game) == false) {
		move.type = ILLEGAL;
		printf("Illegal move!\n");
		return move;
	}
	if (isPromotionValid(from, to, prom, game) == false) {
		printf("Invalid promotion!\n");
		move.type = ILLEGAL;
		return move;
	}

	PieceColor colorThatMoved = game->colorToMove;

	move = makeMove(from, to, prom, game);

//	if (isUnderCheck(colorThatMoved, game)) {
//		undoMove(game);
//		move.type = ILLEGAL;
//	}

	return move;
}

const bool slide[6] = {false, false, true, true, true, false};
const uint8_t offsets[6] = {0, 8, 4, 4, 8, 8}; /* knight or ray directions */
const int8_t offset[6][8] = {
	{   0,   0,  0,  0, 0,  0,  0,  0 },
	{ -21, -19,-12, -8, 8, 12, 19, 21 }, /* KNIGHT */
	{ -11,  -9,  9, 11, 0,  0,  0,  0 }, /* BISHOP */
	{ -10,  -1,  1, 10, 0,  0,  0,  0 }, /* ROOK */
	{ -11, -10, -9, -1, 1,  9, 10, 11 }, /* QUEEN */
	{ -11, -10, -9, -1, 1,  9, 10, 11 }  /* KING */
};

const int8_t mailbox[120] = {
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1,  0,  1,  2,  3,  4,  5,  6,  7, -1,
     -1,  8,  9, 10, 11, 12, 13, 14, 15, -1,
     -1, 16, 17, 18, 19, 20, 21, 22, 23, -1,
     -1, 24, 25, 26, 27, 28, 29, 30, 31, -1,
     -1, 32, 33, 34, 35, 36, 37, 38, 39, -1,
     -1, 40, 41, 42, 43, 44, 45, 46, 47, -1,
     -1, 48, 49, 50, 51, 52, 53, 54, 55, -1,
     -1, 56, 57, 58, 59, 60, 61, 62, 63, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};

const uint8_t mailbox64[64] = {
    21, 22, 23, 24, 25, 26, 27, 28,
    31, 32, 33, 34, 35, 36, 37, 38,
    41, 42, 43, 44, 45, 46, 47, 48,
    51, 52, 53, 54, 55, 56, 57, 58,
    61, 62, 63, 64, 65, 66, 67, 68,
    71, 72, 73, 74, 75, 76, 77, 78,
    81, 82, 83, 84, 85, 86, 87, 88,
    91, 92, 93, 94, 95, 96, 97, 98
};

Bitboard getMoves(Position from, const Game* game)
{
	if (isPosEmptyOrInvalid(from, game)) return C64(0);

	PieceInfo p = game->board[from];
	PieceColor color = getPieceColor(p);
	if (color != game->colorToMove) return C64(0);
	PieceColor enemyColor = getEnemyColor(color);
	PieceType type = getPieceType(p);

	Bitboard bb = C64(0);
	uint8_t rank = getRank(from);
	uint8_t file = getFile(from);

	int8_t i, n;

	if (type != PAWN) {
		for (i = 0; i < offsets[type]; i++) {
			for (n = from;;) {
				n = mailbox[mailbox64[n] + offset[type][i]];
				if (n == -1) break; /* outside board */
				p = game->board[n];
				if (p != NONE) {
					if (getPieceColor(p) == enemyColor) {
						setBit(bb, n);
					}
					break;
				}
				setBit(bb, n);
				if (!slide[type]) break; /* next direction */
			}
		}

		if (type == KING) {
			if (from_rank == color * 7 && from_file == 4) {
				if (isPosUnderAttack(from, enemyColor, game)) return false;
				uint8_t between_file;
				if (to_file == 2) {
					between_file = 3;
					return !isPosUnderAttack(getPos(from_rank, between_file), enemyColor, game)
						&& game->moveCnt <= game->whenLostCR[color][0];
				}
				else if (to_file == 6) {
					between_file = 5;
					return !isPosUnderAttack(getPos(from_rank, between_file), enemyColor, game)
						&& game->moveCnt <= game->whenLostCR[color][1];
				}
				else {
					return (to_file == 3 || from_file == 5);
				}
			}
		}

	}

	else {  // if pawn
		if (color == WHITE) {
			if (game->board[from + 8] == NONE) {
				setBit(bb, from + 8);
			}
			if (rank == 1) {
				if (game->board[from + 16] == NONE) {
					setBit(bb, from + 16);
				}
			}

			p = game->board[from + 9];
			if (p != NONE && getPieceColor(p) == enemyColor) {
				setBit(bb, from + 9);
			}

			p = game->board[from + 7];
			if (p != NONE && getPieceColor(p) == enemyColor) {
				setBit(bb, from + 7);
			}

			if (game->enPassantFile != NONE && rank == 4) {
				if (game->enPassantFile == file + 1)
					setBit(bb, from + 9);
				else if (game->enPassantFile == file - 1)
					setBit(bb, from + 7);
			}
		}

		else { // if black pawn
			
			if (game->board[from - 8] == NONE) {
				setBit(bb, from - 8);
			}
			if (rank == 6) {
				if (game->board[from - 16] == NONE) {
					setBit(bb, from - 16);
				}
			}

			p = game->board[from - 9];
			if (p != NONE && getPieceColor(p) == enemyColor) {
				setBit(bb, from - 9);
			}

			p = game->board[from - 7];
			if (p != NONE && getPieceColor(p) == enemyColor) {
				setBit(bb, from - 7);
			}

			if (game->enPassantFile != NONE && rank == 3) {
				if (game->enPassantFile == file + 1)
					setBit(bb, from - 7);
				else if (game->enPassantFile == file - 1)
					setBit(bb, from - 9);
			}
		}
	}

	return bb;
}

Bitboard getLegalMoves(Position from, const Game* game)
{
	return getMoves(from, game);
}

bool isPosUnderAttack(Position target, PieceColor color, const Game* game)
{
	PieceInfo piece;
	Position pos;

	// check for pawns
	if (color == WHITE) pos = target - 9;
	else pos = target + 7;
	for (int i = 0; i < 2; i++) {
		if (isPosEmptyOrInvalid(pos, game)) continue;
		piece = game->board[pos];
		if (piece == PIECE(color, PAWN)) {
			return true;
		}
		pos += 2;
	}

	// check for knights
	for (int i = 0; i < 8; i++) {
		pos = target + knightMoves[i];
		if (isPosEmptyOrInvalid(pos, game)) continue;
		piece = game->board[pos];
		if (piece == PIECE(color, KNIGHT)) {
			return true;
		}
	}

	// check diagonals for bishops and queens
	for (int i = 0; i < 4; i++) {
		for (int step = 1; step < 8; step++) {
			pos = target + diagonals[i] * step;
			if (isPosValid(pos) == false) break;
			if (isPosEmpty(pos, game)) continue;
			piece = game->board[pos];
			if (piece == PIECE(color, BISHOP)
				|| piece == PIECE(color, QUEEN))
			{
				return true;
			}
			else {
				break;
			}
		}
	}

	// check rank and file for rooks and queens
	for (int i = 0; i < 4; i++) {
		for (int step = 1; step < 8; step++) {
			pos = target + orthogonals[i] * step;
			if (isPosValid(pos) == false) break;
			if (isPosEmpty(pos, game)) continue;
			piece = game->board[pos];
			if (piece == PIECE(color, BISHOP)
				|| piece == PIECE(color, QUEEN))
			{
				return true;
			}
			else {
				break;
			}
		}
	}

	// check for king
	for (int i = 0; i < 8; i++) {
		pos = target + kingMoves[i];
		if (isPosEmptyOrInvalid(pos, game)) continue;
		piece = game->board[pos];
		if (piece == PIECE(color, KING)) {
			return true;
		}
	}

	return false;
}

bool isUnderCheck(PieceColor color, const Game* game)
{
	Piece king = game->pieces[color][0];
	PieceColor enemyColor = getEnemyColor(color);
	return isPosUnderAttack(king.pos, enemyColor, game);
}

/*
bool isPieceAttacking(Position from, Position to, const char board[8][8]) {
	if (isPosEmpty(from, game)) return false;
	PieceInfo piece = getPiece(from, game).info;
	switch(getPieceType(piece))
	{
	case PAWN:
		if (getPieceColor(piece) == WHITE) {
			return from.rank + 1 == to.rank && abs(from.file - to.file) == 1;
		}
		else {
			return from.rank - 1 == to.rank && abs(from.file - to.file) == 1;
		}
		return false;
	case KNIGHT:
		return isKnightMoveLegal(from, to);
	case BISHOP:
		return isBishopMoveLegal(from, to, game);
	case ROOK:
		return isRookMoveLegal(from, to, game);
	case QUEEN:
		return isQueenMoveLegal(from, to, game);
	case KING:
		return isKingMoveLegal(from, to, game);
	default:
		return false;
	}
}

/*
int getPawnAttackMoves(Position from, PieceColor color,
		const char board[8][8], Position moves[])
{
	Position pos;
	int cnt = 0;
	if (color == WHITE) pos.rank = from.rank + 1;
	else pos.rank = from.rank - 1;
	for (int i = -1; i <= 1; i += 2) {
		pos.file = from.file + i;
		if (isPositionValid(pos)) moves[cnt++] = pos;
	}
	return cnt;
}

int getKnightMoves(Position from, const char board[8][8], Position moves[])
{
	Position pos;
	int cnt = 0;
	for (int i = 0; i < 8; i++) {
		pos.rank = from.rank + knightMoves[i][0];
		pos.file = from.file + knightMoves[i][1];
		if (isPositionValid(pos)) moves[cnt++] = pos;
	}
	return cnt;
}

int getBishopMoves(Position from, const char board[8][8], Position moves[])
{
	Piece piece;
	Position pos;
	int cnt = 0;
	for (int i = -1; i <= 1; i += 2) {
		for (int j = -1; j <= 1; j += 2) {
			for (int step = 1; step < 8; step++) {
				pos.rank = from.rank + i * step;
				pos.file = from.file + j * step;
				if (isPositionValid(pos) == false) break;
				if (*getSquare(pos, board) == EMPTY) {
					moves[cnt++] = pos;
				} else {
					moves[cnt++] = pos;
					break;
				}
			}
		}
	}
	return cnt;
}

int getRookMoves(Position from, const char board[8][8], Position moves[])
{
	Piece piece;
	Position pos;
	int cnt = 0;
	pos.rank = from.rank;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.file = from.file + i * step;
			if (isPositionValid(pos) == false) break;
			if (*getSquare(pos, board) == EMPTY) {
				moves[cnt++] = pos;
			} else {
				moves[cnt++] = pos;
				break;
			}
		}
	}
	pos.file = from.file;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.rank = from.rank + i * step;
			if (isPositionValid(pos) == false) break;
			if (*getSquare(pos, board) == EMPTY) {
				moves[cnt++] = pos;
			} else {
				moves[cnt++] = pos;
				break;
			}
		}
	}
	return cnt;
}

int getQueenMoves(Position from, const char board[8][8], Position moves[])
{
	int nBishopMoves = getBishopMoves(from, board, moves);
	int nRookMoves = getRookMoves(from, board, moves + nBishopMoves);
	return nBishopMoves + nRookMoves;
}

int getKingMoves(Position from, const char board[8][8], Position moves[])
{
	Position pos;
	int cnt = 0;
	for (int i = 0; i < 8; i++) {
		pos.rank = from.rank + kingMoves[i][0];
		pos.file = from.file + kingMoves[i][1];
		if (isPositionValid(pos)) moves[cnt++] = pos;
	}
	return cnt;
}

int getControlledPositions(PieceInfo piece, const char board[8][8], Position controlled[])
{
	switch(piece.piece.type)
	{
	case TYPE_NONE:
		return 0;

	case PAWN:
		return getPawnAttackMoves(piece.pos, piece.piece.color, board, controlled);

	case KNIGHT:
		return getKnightMoves(piece.pos, board, controlled);

	case BISHOP:
		return getBishopMoves(piece.pos, board, controlled);

	case ROOK:
		return getRookMoves(piece.pos, board, controlled);

	case QUEEN:
		return getQueenMoves(piece.pos, board, controlled);

	case KING:
		return getKingMoves(piece.pos, board, controlled);

	default:
		return 0;
	}
}

PieceInfo getKingInfo(PieceColor color, const char board[8][8])
{
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			Piece piece = getPiece(board[i][j]);
			if (piece.color == color)
				return (PieceInfo){piece, (Position){.rank=i, .file=j}};
		}
	}
}

int getPiecesByColor(PieceColor color, const char board[8][8], PieceInfo pieces[16])
{
	int cnt = 0;
	Piece piece;
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			piece = getPiece(board[i][j]);
			if (piece.color == color) {
				pieces[cnt++] = (PieceInfo){piece, (Position){.rank=i, .file=j}};
			}
		}
	}
	return cnt;
}

int updatePieces(Move* move, PieceInfo pieces[2][16]) {
	PieceColor color = getPieceColor(move->piece);
	PieceColor enemyColor = getEnemyColor(color);
	for (int i = 0; i < nPieces[color]; i++) {
		Piece* p = &pieces[color][i];
		if (isPositionEqual(p->pos, move->from)) {
			p->pos = move->to;
		}
	}
	Position capPos;
	if (move->isEnPassant) {
		capPos.rank = move->to.rank;
		capPos.file = move->from.file;
	} else capPos = move->to;

	for (int i = 0; i < nPieces[enemyColor]; i++) {
		Piece* p = &pieces[enemyColor][i];
		if (isPositionEqual(p->pos, capPos)) {
			p->pos.rank = -1;
			p->pos.file = -1;
		}
	}
}

int getIndexToKing(const PieceInfo pieces[16], int n)
{
	for(int i = 0; i < n; i++) {
		if (pieces[i].piece.type == KING) {
			return i;
		}
	}
	return -1;
}

void calculateControlBoard(Game* game)
{
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			for (int c = 0; c < 2; c++) {
				game->controlBoard[i][j][c] = 0;
			}
		}
	}
	Position pos[MAX_LEGAL_MOVES];
	uint8_t rank, file;
	for (int i = 0; i < 2; i++) {
		printf("%d\n", game->nPieces[i]);
		for (int j = 0; j < game->nPieces[i]; j++) {
			Piece p = game->pieces[i][j];
			if (p.pos == NONE) continue;
			int nPos = getControlledPositions(p, game->refBoard, pos);
//			printf("%d%c @ %c%d - %d\n", p.piece.color, p.piece.type,
//				p.pos.file + 'a', p.pos.rank + 1, nPos);
			for (int k = 0; k < nPos; k++) {
				rank = pos[k].rank;
				file = pos[k].file;
				game->controlBoard[rank][file][i] += 1;
			}
		}
	}
}

void updateControl(PieceInfo pieces, int n, Game* game,
	UpdateControlOption opt)
{
	for (int i = 0; i < n; i++) {
		int nPos = getControlledPositions(p, game->refBoard, pos);
		pieces[];
	}
}

int getLongAttackers(Position target, const char board[8][8], PieceInfo attackers[])
{
	int cnt = 0;
	Piece piece;
	Position pos;

	for (int i = -1; i <= 1; i += 2) {
		for (int j = -1; j <= 1; j += 2) {
			for (int step = 1; step < 8; step++) {
				pos.rank = target.rank + i * step;
				pos.file = target.file + j * step;
				if (isPositionValid(pos) == false) break;
				piece = getPiece(*getSquare(pos, board));
				if (piece.type == BISHOP || piece.type == QUEEN) {
					attackers[cnt++] = (PieceInfo){piece, pos};
					break;
				}
			}
		}
	}

	pos.rank = target.rank;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.file = target.file + i * step;
			if (isPositionValid(pos) == false) break;
			piece = getPiece(*getSquare(pos, board));
			if (piece.type == ROOK || piece.type == QUEEN) {
				attackers[cnt++] = (PieceInfo){piece, pos};
				break;
			}
		}
	}

	pos.file = target.file;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.rank = target.rank + i * step;
			if (isPositionValid(pos) == false) break;
			piece = getPiece(*getSquare(pos, board));
			if (piece.type == ROOK || piece.type == QUEEN) {
				attackers[cnt++] = (PieceInfo){piece, pos};
				break;
			}
		}
	}
	return cnt;
}

int getAffectedAttackers(MoveInfo* move, const char board[8][8],
	PieceInfo attackers[]);
{
	int cnt = 0;
	Piece piece;
	Position pos1, pos2;

	for (int i = -1; i <= 1; i += 2) {
		for (int j = -1; j <= 1; j += 2) {
			for (int step = 1; step < 8; step++) {
				pos1.rank = move->from.rank + i * step;
				pos1.file = move->from.file + j * step;
				pos2.rank = move->to.rank + i * step;
				pos2.file = move->to.file + j * step;
				if (isPositionValid(pos) == false) break;
				if (isPositionEqual(pos, move->to)) {
					break;
				}
				piece = getPiece(*getSquare(pos, board));
				if (piece.type == BISHOP || piece.type == QUEEN) {
					attackers[cnt++] = (PieceInfo){piece, pos};
					break;
				}
			}
		}
	}

	pos.rank = move->from.rank;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.file = move->from.file + i * step;
			if (isPositionValid(pos) == false) break;
			if (isPositionEqual(pos, move->to)) {
				break;
			}
			piece = getPiece(*getSquare(pos, board));
			if (piece.type == ROOK || piece.type == QUEEN) {
				move->affectedAttackers[cnt++] = (PieceInfo){piece, pos};
				break;
			}
		}
	}

	pos.file = move->from.file;
	for (int i = -1; i <= 1; i += 2) {
		for (int step = 1; step < 8; step++) {
			pos.rank = move->from.rank + i * step;
			if (isPositionValid(pos) == false) break;
			if (isPositionEqual(pos, move->to)) {
				break;
			}
			piece = getPiece(*getSquare(pos, board));
			if (piece.type == ROOK || piece.type == QUEEN) {
				move->affectedAttackers[cnt++] = (PieceInfo){piece, pos};
				break;
			}
		}
	}
	return cnt;
}
*/
